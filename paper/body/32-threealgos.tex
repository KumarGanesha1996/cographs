\section{Coloring, maximal independent set and maximal clique}

These three algorithms are implemented using \ref{algos:template} template. Their implementation is described by simply describing $hl, hj, hu$ functions and proving their correctness.

\subsection{Coloring}

Coloring is a problem of finding a function $f\colon V \mapsto \{1, \ldots, n\}$ for a graph $G = (V,E)$, such that $\forall_{\{u,v\} \in E} f(u) \neq f(v)$ and $n$ is the smallest possible. This problem is NP-Complete in general case as shown in \cite{karp}, but can be solved in polynomial time on cographs.

The functions $hl, hj$ and $hu$ are presented below:
\begin{enumerate}
    \item $hl$

          This is the base case and it represents a single leaf. It is indeed possible to use a single color to color it since there are no edges in $\singleton{v}$. Therefore the function is defined as:
          \[
              hl(v) = \{(v,1)\}
          \]

    \item $hj$

          In this case we have to return a coloring function $f$ for $\Gjoin{G_1}{G_2} = (V,E)$ given coloring functions $f_1,f_2$ for $G_1 = (V_1, E_1), G_2 = (V_2, E_2)$ respectively. Since $\{v_1, v_2\} \in E$ for each $v_1 \in V_1, v_2 \in V_2$ it follows that $f(v_1) \neq f(v_2)$. Moreover for each $\{u,v\} \in E_i$ it must be so that $f(u) \neq f(v)$. Let $n$ be the highest number in the image of $f_1$ ($f\colon V_1 \mapsto \{1, \ldots, n\}$). We define $hj$ so that
          \[
              hj(f_1, f_2)(v) = \begin{cases}
                  f_1(v)     & \text{if } v \in V_1 \\
                  n + f_2(v) & \text{if } v \in V_2 \\
              \end{cases}
          \]
          Let us notice that function $f = hj(f_1, f_2)$ satisfies the first condition since $f(v_1) = f_1(v_1) \leq n < n+1 \leq n + f_2(v_2) = f(v_2)$. It also satisfies the second condition since $f(u) = f_1(u) \neq f_1(v) = f(v)$ for $i = 1$ and $f(u) = n + f_2(u) \neq n + f_2(v) = f(v)$ for $i = 2$ (the central inequalities arise from the fact that $f_1, f_2$ are proper colorings of $G_1, G2$ respectively).

          This also produces $f$ with the smallest image since if smaller existed one could easily obtain smaller colorings for $G_1$ or $G_2$ by restricting the $f$ to $V_1$ or $V_2$ respectively. This would contradict the assumption that $f_1$ and $f_2$ are proper colorings.


    \item $hu$

          In this case we have to return a coloring function $f$ for $\Gjoin{G_1}{G_2} = (V,E)$ given coloring functions $f_1,f_2$ for $G_1 = (V_1, E_1), G_2 = (V_2, E_2)$ respectively. Since $E = E_1 \cup E_2$ it is easy to see that a simple union of functions is enough to satisfy coloring conditions. Therefore:

          \[
              hu(f_1, f_2) = f_1 \cup f_2
          \]
\end{enumerate}

If the functions are represented as lists of lists of vertices, one can simply implement the $hu$ and $hj$ by concatenating respectively lists of vertices and the whole list. Concatenation of the whole list can be done in $O(1)$ time, and concatenation of the lists of vertices can be done in $O(\min(|L_1|, |L_2|))$ time, where $L_1, L_2$ are the main lists being merged. Since in order to extend the main lists the $hj$ function must be run it follows that $\sum \min(|L_1|, |L_2|) = O(\text{number of $hj$ calls})$, which means that the whole algorithm runs in $O(\abs{\V(T)})$ size which is $O(\abs{\V(\G(T))} + \abs{\E(\G(T))})$.